Based on Utku Ufuk's video serioes on Youtube:
https://www.youtube.com/watch?v=zacLahqmlf0&index=1&list=PL36SguL4LIwmhgHkziX-2C91SOTQl1rEL

...only started writing this from the 5th lessons, so maybe do a retroactive naration later.

# Lesson 5 - Creating an Army of pieces

We need to build an "Army" so we can keep track of the pieces for each side (Black/White).
It should hold two lists:
	1. Live pieces
	2. Dead pieces
Wonder if we need separate black and white army ?

# Lesson 6 - Create the Feature Plug-In

This video handles linking of the two plugins together.
One holds the engine and the other holds the actual app (UI).

Core needs not be aware of anything outside of itself, so it will be one way dependency.

First, cereate a new feature project, in which the included plugins need to be added.
Those are the two we created.
Then, in UI plugin in the Content tab of the product the feature needs to be added.
Also following features need to be added as well:
<feature id="org.eclipse.e4.rcp" version="1.6.300.v20181204-1801"/>
<feature id="org.eclipse.emf.ecore" version="2.16.0.v20181124-0637"/>
<feature id="org.eclipse.emf.common" version="2.15.0.v20180914-1817"/>

Remove the versions, so there won't be any compatibility issues.

Further, for the functionality we need to add the ChessRoom, where the game will be managed.
From the ChessBoardPart the ChessRoom will be referenced, because we do not want to 
overcrowd the ChessBoardPart, which should only handle the visual part.

# Lesson 7 - Building the Chess Room

Not much to discuss here, except the fact that in the MANIFEST.MD exports and imports need to be handled so the packages would be visible in different plugins.
Adding the board to the chess room and adding the pieces to the board.

# Lesson 8 - Displaying initial board state

The board state has been decided in the ChessRoom class, now we have to display it.
Firtsly display it with syso in the console, just for the sake of it.
Not a big deal, but what is interesting is the black pieces will be diplsayed on the bottom.
This should not be the case.
What Utku sugests is to reverse the parsing of the board when displaying it.
I'm thinking that the board should be created reversed from the beginning.
We'll see.
Also, there should be a reverse functionality.

# Lesson 9 - Creating Plug-In for Chess Player

A separate plugin to be created to represent the Chess Player.
Also a class is added called ChessPlayer, which will hold the board and the side.
A method makeMove is implemented which will handle the moving of the piece:
- changing the square to which it belongs
- changing the properties of the square
- handle the case of capturing

It is presumed that the move is valid.
This will be checked elsewhere.

# Lesson 10 - Computing Legal Moves

Legal moves for each piece will be computed, after which those moves will be merged as all available legal moves for a player.
A lot of loops, this could and should all be done with streams.
Will convert all of this later.

# Lesson 11 - Relative Square Access

This refers to the possibility of accessing another square given an existing one.
For example sq1.access(row+2, col-1);

# Lesson 12 - Computing Legal Moves for Knight

Need to define the possible moves for the Knight and then check them all.
A move is illegal if:
- it takes a piece of the board
- on the target square one of own pieces exist
- targe square has no piece or oponnent piece
Additionally, but not implemented (valid for all pieces):
- cannot move piece it if uncovers chess

8 possible moves for the night with different offset.
Would like to refactor the calculation, if possible.

# Lesson 13 - Computing Legal Moves for Knight

Same move legality applies as for the Knight.
King's movement is done in two nested 4 loops, from -1 to 1, giving all 9 possible positions.
The 0,0 is considered invalid, because own piece (the King) is on that square.

Moved checking of the validity to the Piece class since it's reusable.
Wonder how the chess uncover will be implemented.

# Lesson 14 - Computing Legal Moves for Pawns

Pawns only move forward, but be aware that Black moves backwards since our board is fixed, at least from program's perspective.
Take care of two squares move on the first pawn move and capturing on the diagonal as well.
In the future take care of En Passant and Pawn Promotion.

# Lesson 15 - Computing Linear Moves

For Bishop, Queen and Rook the moves are lineary infinite (limited to the board of course).

One computeLinearMoves should be defined, and it can be used for the rest of the pieces.
How ? Loop over squares for all 4 directions until either:
- end is reached (so getAdjescentSquare returns null)
- own piece reached -> break (it's invalid)
- oponnent piece reached -> break (it's valid though)
To maintain the loop just getAdjescentSquare squre from the previously gotten adjescent square.
Easy.

# Lesson 16 - Computing Legal Moves for Rook, Bishop and Queen

Just use the computeLinearMoves with directions for all three.
For the queen a for loop can be used to avoid code duplication.

# Lesson 17 - Creating the first SWT widget

Create a GridData widget, add the data to it, bu accessing the chessRoom, getting the Board and then the sqyare.
Put the text in the matrix by getting the Piece of the square (if there is one) and accessing its toString() overriden method.

# Lesson 18 - Add row numbers and column letters to the board

Need to add an extra row of labels.
Also take care of the square that's before the letter A and before the number 1.

# Lesson 19 - Add piece icons

Find the images and add them to the plugin.
Create a handler, which is set in the code plugin, which I do not like, but alas.
Add the icon to the Piece constructor, and odify all the calls to the specific pieces. Should be improved.
Maybe create a factory.

# Lesson 20 - Setting the background colors of the squares

First move the logic for piece setting on the board to the setFocus method.
Also call that method in the PostConstruct once to make the initial setting.
After that add the code to color the squares accordingly.
Utku does this in setFocus method. Not sure why thoguh.
Answer: in the future when the mvoe is made, we need to see the possible moves highlited.
This can only be done if we move the logic to setFocus. Ha !

# Lesson 21 - Create a Random Player

Need to change the ChessPlayer class.
decideMove method is edited for deciding which move to make based on the Algorithm.
Randomize the selection and the moves. Also add a toString override so we know what are we facing.

Need to add a player to the ChessRoom.
Use Map to store players so we can retreive them by the side.

Note: once you make a change to the feature, you need to lunch the application from the procudt file.

# Lesson 22 - Creating Listeners

Add a package for listeners.
Add a ChessMoveListener class.
Implement the three override methods.

But first add mouse listeners to the squares, in the setFocus, inside the ChessBoardPart.
Need the legal flag on each square so we can use it to color the square.

Implement the mouseDoubleClick for the listener, which will mark the legal moves.

# Lesson 23 - Highlighting legal moves

Additional functionality to the mouseDoubleClick of the listener.
Need to make sure that after the mouseDoubleClick method is done the setFocus is called immediately.
Will call the setFocus method in the mouseUp method of the listener.
Add a new PartRefresher class which will refresh all (or some) of the parts.
e.g. we'll add a graveyard part for the captured pieces.

Need to fix the bug where the legal moves do not get reset.
Utku does some cross referencing which I do not like.
Should change that.

# Lesson 24 - Making Moves with mouse clicks

Maine changes to ChessMoveListener.

# Lesson 25 - Implementing the turn mechanism

Implementing the RandomMove maker, which will get active on the mouseDown.
So, after making a move, an additional single click needs to be made so the 
"AI" will make its move.
Weird.

# Lesson 26 - Displaying graveyard parts

Need to add PartStack for two graveyards.
One on the left and one on the right.
Will need 16 labels each, for all the existing pieces that can be captured.
Creating classes similar to the ChessBoardPart.
There will be on Graveyard class, from which two child classes will spawn.

Change the relative dimensions for each part stack.
Set the Conatainer Data for each stack, so the parts will be resized automatically.

# Lesson 27 - 