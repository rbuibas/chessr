Based on Utku Ufuk's video serioes on Youtube:
https://www.youtube.com/watch?v=zacLahqmlf0&index=1&list=PL36SguL4LIwmhgHkziX-2C91SOTQl1rEL

...only started writing this from the 5th lessons, so maybe do a retroactive naration later.

# Lesson 5 - Creating an Army of pieces

We need to build an "Army" so we can keep track of the pieces for each side (Black/White).
It should hold two lists:
	1. Live pieces
	2. Dead pieces
Wonder if we need separate black and white army ?

# Lesson 6 - Create the Feature Plug-In

This video handles linking of the two plugins together.
One holds the engine and the other holds the actual app (UI).

Core needs not be aware of anything outside of itself, so it will be one way dependency.

First, cereate a new feature project, in which the included plugins need to be added.
Those are the two we created.
Then, in UI plugin in the Content tab of the product the feature needs to be added.
Also following features need to be added as well:
<feature id="org.eclipse.e4.rcp" version="1.6.300.v20181204-1801"/>
<feature id="org.eclipse.emf.ecore" version="2.16.0.v20181124-0637"/>
<feature id="org.eclipse.emf.common" version="2.15.0.v20180914-1817"/>

Remove the versions, so there won't be any compatibility issues.

Further, for the functionality we need to add the ChessRoom, where the game will be managed.
From the ChessBoardPart the ChessRoom will be referenced, because we do not want to 
overcrowd the ChessBoardPart, which should only handle the visual part.

# Lesson 7 - Building the Chess Room

Not much to discuss here, except the fact that in the MANIFEST.MD exports and imports need to be handled so the packages would be visible in different plugins.
Adding the board to the chess room and adding the pieces to the board.

# Lesson 8 - Displaying initial board state

The board state has been decided in the ChessRoom class, now we have to display it.
Firtsly display it with syso in the console, just for the sake of it.
Not a big deal, but what is interesting is the black pieces will be diplsayed on the bottom.
This should not be the case.
What Utku sugests is to reverse the parsing of the board when displaying it.
I'm thinking that the board should be created reversed from the beginning.
We'll see.
Also, there should be a reverse functionality.

# Lesson 9 - Creating Plug-In for Chess Player

A separate plugin to be created to represent the Chess Player.
Also a class is added called ChessPlayer, which will hold the board and the side.
A method makeMove is implemented which will handle the moving of the piece:
- changing the square to which it belongs
- changing the properties of the square
- handle the case of capturing

It is presumed that the move is valid.
This will be checked elsewhere.

# Lesson 10 - Computing Legal Moves

Legal moves for each piece will be computed, after which those moves will be merged as all available legal moves for a player.
A lot of loops, this could and should all be done with streams.
Will convert all of this later.

# Lesson 11 - Relative Square Access

This refers to the possibility of accessing another square given an existing one.
For example sq1.access(row+2, col-1);

# Lesson 12 - Computing Legal Moves for Knight

Need to define the possible moves for the Knight and then check them all.
A move is illegal if:
- it takes a piece of the board
- on the target square one of own pieces exist
- targe square has no piece or oponnent piece
Additionally, but not implemented (valid for all pieces):
- cannot move piece it if uncovers chess

8 possible moves for the night with different offset.
Would like to refactor the calculation, if possible.

# Lesson 13 - Computing Legal Moves for Knight

Same move legality applies as for the Knight.
King's movement is done in two nested 4 loops, from -1 to 1, giving all 9 possible positions.
The 0,0 is considered invalid, because own piece (the King) is on that square.

Moved checking of the validity to the Piece class since it's reusable.
Wonder how the chess uncover will be implemented.

# Lesson 14 - Computing Legal Moves for Pawns

Pawns only move forward, but be aware that Black moves backwards since our board is fixed, at least from program's perspective.
Take care of two squares move on the first pawn move and capturing on the diagonal as well.
In the future take care of En Passant and Pawn Promotion.

# Lesson 14 - Computing Linear Moves